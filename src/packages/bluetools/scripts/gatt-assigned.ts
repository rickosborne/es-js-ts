import { catchAnd, zeroPad } from "@rickosborne/foundation";
import { writeFile } from "node:fs/promises";
import { resolve as pathResolve } from "node:path";
import { fetchAndCacheText } from "./fetch-and-cache-text.js";

interface GattIds {
	fileName: string;
	id: number;
	label?: string | undefined,
	lineNum: number;
	name: string;
	uuid: string;
}

const registryUrl = (fileName: string): string => {
	return `https://raw.githubusercontent.com/WebBluetoothCG/registries/refs/heads/master/${ fileName }`;
};

const sigUrl = (fileName: string): string => {
	return `https://bitbucket.org/bluetooth-SIG/public/raw/main/assigned_numbers/uuids/${fileName}`;
};

const gattIdsComparator = (a: GattIds, b: GattIds) => a.name.localeCompare(b.name);

/**
 * Because I'm too lazy to integrate a YAML library, and these are simple enough.
 */
const idsFromYaml = (text: string, fileName: string): GattIds[] => {
	const ids: GattIds[] = [];
	let currentId: Partial<GattIds> = {};
	let lineNum = 0;
	for (const full of text.split("\n")) {
		lineNum++;
		let line = full.trim();
		if (line.startsWith("#") || line.startsWith("uuids:")) {
			continue;
		}
		if (line.startsWith("-")) {
			if (currentId.id != null && currentId.uuid != null && currentId.name) {
				ids.push({
					...currentId as GattIds,
					fileName,
					lineNum,
				});
				currentId = {};
			}
			line = line.replace(/^-\s+/, "");
		}
		const kv = /^(\w+):\s+(.*)$/.exec(line);
		if (kv == null) {
			continue;
		}
		const [ , key, value ] = kv as unknown as [string, string, string];
		if (key === "uuid") {
			currentId.id = Number.parseInt(value.replace("0x", ""), 16);
			currentId.uuid = "0000".concat(value.replace("0x", "").toLocaleLowerCase(), "-0000-1000-8000-00805f9b34fb");
		} else if (key === "name") {
			currentId.label = value;
		} else if (key === "id") {
			currentId.name = value.replace(/^org\.bluetooth\.[^.]+\./, "");
		}
	}
	return ids.sort(gattIdsComparator);
};

const fetchYaml = async (fileName: string): Promise<GattIds[]> => {
	const url = sigUrl(fileName);
	const text = await fetchAndCacheText(url);
	return idsFromYaml(text, fileName);
};

const reservedWords: string[] = [ "boolean" ];

const fetchIds = async (fileName: string): Promise<GattIds[]> => {
	const url = registryUrl(fileName);
	const text = await fetchAndCacheText(url);
	return text.split("\n")
		.map((line, index) => [ index + 1, line.trim() ] as [ number, string ])
		.filter(([ _lineNum, line ]) => !line.startsWith("#") && line !== "")
		.map(([ lineNum, line ]) => {
			const match = /^(\S+) ([-0-9a-fA-F]{36})$/.exec(line);
			if (match == null || match.length !== 3) {
				console.warn(`(${ fileName }:${ lineNum }) Unexpected line: ${ line }`);
				return undefined;
			}
			const [ _all, name, uuid ] = match as unknown as [ string, string, string ];
			const id = Number.parseInt(uuid.split("-")[ 0 ]!.replace(/^0+/, ""), 16);
			return { fileName, id, lineNum, name, uuid: uuid.toLocaleLowerCase() };
		})
		.filter((ids) => ids != null)
		.sort(gattIdsComparator);
};

interface GattIdGroups {
	characteristics: GattIds[];
	descriptors: GattIds[];
	services: GattIds[];
}

const mergeIds = (dest: GattIds[], source: GattIds[]): void => {
	const ids = new Set(dest.map((c) => c.id));
	const lengthBefore = dest.length;
	for (const char of source) {
		if (!ids.has(char.id)) {
			dest.push(char);
		}
	}
	if (lengthBefore !== dest.length) {
		dest.sort(gattIdsComparator);
	}
};

const fetchData = async (): Promise<GattIdGroups> => {
	const outdatedServices = await fetchIds("gatt_assigned_services.txt");
	const outdatedDescriptors = await fetchIds("gatt_assigned_descriptors.txt");
	const outdatedCharacteristics = await fetchIds("gatt_assigned_characteristics.txt");
	const characteristics = await fetchYaml("characteristic_uuids.yaml");
	const descriptors = await fetchYaml("descriptors.yaml");
	const services = await fetchYaml("service_uuids.yaml");
	mergeIds(characteristics, outdatedCharacteristics);
	mergeIds(descriptors, outdatedDescriptors);
	mergeIds(services, outdatedServices);
	return { characteristics, descriptors, services };
};

const asTable = (ids: GattIds[]): string => {
	const lines = ids.map(({ id, label, name }): string => {
		let key: string;
		if (/^\p{ID_Start}\p{ID_Continue}+$/u.test(name) && !reservedWords.includes(name)) {
			key = name;
		} else {
			key = JSON.stringify(name);
		}
		const hex = zeroPad(id, 4, 16);
		return `\t${key}: [ 0x${hex}, ${label == null ? "undefined" : JSON.stringify(label)} ],`;
	});
	return lines.join("\n").concat("\n");
};

const generateAssignedTS = (groups: GattIdGroups): string => {
	return [
		"// This file is automatically generated.  Do not edit by hand.",
		"",
		`export const GATT_SERVICE_TABLE = Object.freeze({\n${asTable(groups.services)}} as const);`,
		"",
		`export const GATT_CHARACTERISTIC_TABLE = Object.freeze({\n${asTable(groups.characteristics)}} as const);`,
		"",
		`export const GATT_DESCRIPTOR_TABLE = Object.freeze({\n${asTable(groups.descriptors)}} as const);`,
	].join("\n").concat("\n");
};

const gattAssigned = async (): Promise<void> => {
	const outFile = pathResolve(__dirname, "..", "assigned.ts");
	const data = await fetchData();
	const ts = generateAssignedTS(data);
	await writeFile(outFile, ts, { encoding: "utf-8" });
};

gattAssigned().catch(catchAnd({ rethrow: true }));
