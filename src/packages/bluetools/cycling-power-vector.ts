import { type DataViewReader, dataViewReader } from "./data-view-reader.js";

// This file is autogenerated.
// Do not edit it by hand, as changes will be lost.
// Upstream source: https://raw.githubusercontent.com/oesmith/gatt-xml/refs/heads/master/org.bluetooth.characteristic.cycling_power_vector.xml
/** <p>The Cycling Power Vector characteristic is a variable length structure containing a Flags fieldand based on the contents of the Flags field, may contain one or more additional fields as shown in the table below.</p> */
export interface CyclingPowerVector {
    /**
     * <p>Format: `uint16`</p>
     * <p>Unit: `org.bluetooth.unit.unitless`</p>
     */
    crankRevolutionDataCumulativeCrankRevolutions?: number | undefined;
    /**
     * <p>Format: `uint16`</p>
     * <p>Unit: `org.bluetooth.unit.time.second`</p>
     */
    crankRevolutionDataLastCrankEventTime?: number | undefined;
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    crankRevolutionDataPresent: number;
    /**
     * <p>When observed with the front wheel to the right of the pedals, a value of 0 degrees represents the angle when the crank is in the 12 o'clock position and a value of 90 degrees represents the angle, measured clockwise, when the crank points towards the front wheel in a 3 o'clock position. The left crank sensor (if fitted) detects the 0? when the crank it is attached to is in the 12 o'clock position and the right sensor (if fitted) detects the 0? when the crank it is attached to is in its 12 o'clock position; thus, there is a constant 180? difference between the right crank and the left crank position signals.</p>
     * <p>Format: `uint16`</p>
     * <p>Unit: `org.bluetooth.unit.plane_angle.degree`</p>
     * <p>Unit is in degrees with a resolution of 1.</p>
     */
    firstCrankMeasurementAngle?: number | undefined;
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    firstCrankMeasurementAnglePresent: number;
    /**
     * <p>Format: `8bit`</p>
     *
     * Bit field:
     *
     * | index | size | name                                         |
     * | ----- | ---- | -------------------------------------------- |
     * | 0     | 1    | Crank Revolution Data Present                |
     * | 1     | 1    | First Crank Measurement Angle Present        |
     * | 2     | 1    | Instantaneous Force Magnitude Array Present  |
     * | 3     | 1    | Instantaneous Torque Magnitude Array Present |
     * | 4     | 2    | Instantaneous Measurement Direction          |
     * | 6     | 2    | Reserved for future use                      |
     *
     */
    flags: number;
    /**
     * <p>Format: `sint16`</p>
     * <p>Unit: `org.bluetooth.unit.force.newton`</p>
     */
    instantaneousForceMagnitudeArray?: number | undefined;
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    instantaneousForceMagnitudeArrayPresent: number;
    /**
     * | value | description          |
     * | ----- | -------------------- |
     * | 0     | Unknown              |
     * | 1     | Tangential Component |
     * | 2     | Radial Component     |
     * | 3     | Lateral Component    |
     */
    instantaneousMeasurementDirection: number;
    /**
     * <p>Format: `sint16`</p>
     * <p>Unit: `org.bluetooth.unit.moment_of_force.newton_metre`</p>
     */
    instantaneousTorqueMagnitudeArray?: number | undefined;
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    instantaneousTorqueMagnitudeArrayPresent: number;
}

/**
 * The fields in the above table, reading from top to bottom, are shown in the order of LSO to MSO, where LSO = Least Significant Octet and MSO = Most Significant Octet. The Least Significant Octet represents the eight bits numbered 0 to 7.
 * @see {@link https://raw.githubusercontent.com/oesmith/gatt-xml/refs/heads/master/org.bluetooth.characteristic.cycling_power_vector.xml | Cycling Power Vector}
 */
export class CyclingPowerVectorImpl implements CyclingPowerVector {
    public static readonly UUID_PREFIX = 0x2a64;
    public static readonly TYPE_NAME = "org.bluetooth.characteristic.cycling_power_vector";
    public static readonly NAME = "Cycling Power Vector";

    /** Parse from a DataView into {@link CyclingPowerVector}. */
    public static fromDataView(dataView: DataView | DataViewReader, indexStart?: number | undefined): CyclingPowerVectorImpl {
        return new CyclingPowerVectorImpl(cyclingPowerVectorFromDataView(dataView, indexStart));
    }

    public readonly crankRevolutionDataCumulativeCrankRevolutions?: number | undefined;
    public readonly crankRevolutionDataLastCrankEventTime?: number | undefined;
    public readonly crankRevolutionDataPresent: number;
    public readonly firstCrankMeasurementAngle?: number | undefined;
    public readonly firstCrankMeasurementAnglePresent: number;
    public readonly flags: number;
    public readonly instantaneousForceMagnitudeArray?: number | undefined;
    public readonly instantaneousForceMagnitudeArrayPresent: number;
    public readonly instantaneousMeasurementDirection: number;
    public readonly instantaneousTorqueMagnitudeArray?: number | undefined;
    public readonly instantaneousTorqueMagnitudeArrayPresent: number;

    public constructor(cyclingPowerVector: CyclingPowerVector) {
        this.crankRevolutionDataCumulativeCrankRevolutions = cyclingPowerVector.crankRevolutionDataCumulativeCrankRevolutions;
        this.crankRevolutionDataLastCrankEventTime = cyclingPowerVector.crankRevolutionDataLastCrankEventTime;
        this.crankRevolutionDataPresent = cyclingPowerVector.crankRevolutionDataPresent;
        this.firstCrankMeasurementAngle = cyclingPowerVector.firstCrankMeasurementAngle;
        this.firstCrankMeasurementAnglePresent = cyclingPowerVector.firstCrankMeasurementAnglePresent;
        this.flags = cyclingPowerVector.flags;
        this.instantaneousForceMagnitudeArray = cyclingPowerVector.instantaneousForceMagnitudeArray;
        this.instantaneousForceMagnitudeArrayPresent = cyclingPowerVector.instantaneousForceMagnitudeArrayPresent;
        this.instantaneousMeasurementDirection = cyclingPowerVector.instantaneousMeasurementDirection;
        this.instantaneousTorqueMagnitudeArray = cyclingPowerVector.instantaneousTorqueMagnitudeArray;
        this.instantaneousTorqueMagnitudeArrayPresent = cyclingPowerVector.instantaneousTorqueMagnitudeArrayPresent;
    }
}

/** Parse from a DataView into {@link CyclingPowerVector}. */
export function cyclingPowerVectorFromDataView(dataView: DataView | DataViewReader, indexStart: number = 0): CyclingPowerVector {
    const $dvr: DataViewReader = dataViewReader(dataView, indexStart);
    const flags = $dvr.uint8();
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    const crankRevolutionDataPresent = flags & 0b0000_0001;
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    const firstCrankMeasurementAnglePresent = (flags & 0b0000_0010) >> 1;
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    const instantaneousForceMagnitudeArrayPresent = (flags & 0b0000_0100) >> 2;
    /**
     * | value | description |
     * | ----- | ----------- |
     * | 0     | False       |
     * | 1     | True        |
     */
    const instantaneousTorqueMagnitudeArrayPresent = (flags & 0b0000_1000) >> 3;
    /**
     * | value | description          |
     * | ----- | -------------------- |
     * | 0     | Unknown              |
     * | 1     | Tangential Component |
     * | 2     | Radial Component     |
     * | 3     | Lateral Component    |
     */
    const instantaneousMeasurementDirection = (flags & 0b0011_0000) >> 4;
    let crankRevolutionDataCumulativeCrankRevolutions: number | undefined = undefined;
    if (crankRevolutionDataPresent) {
        crankRevolutionDataCumulativeCrankRevolutions = $dvr.uint16();
    }

    let crankRevolutionDataLastCrankEventTime: number | undefined = undefined;
    if (crankRevolutionDataPresent) {
        crankRevolutionDataLastCrankEventTime = $dvr.uint16();
    }

    const firstCrankMeasurementAngle = $dvr.uint16();
    let instantaneousForceMagnitudeArray: number | undefined = undefined;
    if (instantaneousForceMagnitudeArrayPresent) {
        instantaneousForceMagnitudeArray = $dvr.int16();
    }

    let instantaneousTorqueMagnitudeArray: number | undefined = undefined;
    if (instantaneousForceMagnitudeArrayPresent) {
        instantaneousTorqueMagnitudeArray = $dvr.int16();
    }

    return { crankRevolutionDataCumulativeCrankRevolutions, crankRevolutionDataLastCrankEventTime, crankRevolutionDataPresent, firstCrankMeasurementAngle, firstCrankMeasurementAnglePresent, flags, instantaneousForceMagnitudeArray, instantaneousForceMagnitudeArrayPresent, instantaneousMeasurementDirection, instantaneousTorqueMagnitudeArray, instantaneousTorqueMagnitudeArrayPresent };
}
