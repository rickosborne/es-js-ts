import { catchAnd } from "@rickosborne/foundation";
import { writeFile } from "node:fs/promises";
import { resolve as pathResolve } from "node:path";
import { fetchAndCacheText } from "./fetch-and-cache-text.js";

interface GattIds {
	fileName: string;
	id: number;
	lineNum: number;
	name: string;
	uuid: string;
}

const registryUrl = (fileName: string): string => {
	return `https://raw.githubusercontent.com/WebBluetoothCG/registries/refs/heads/master/${ fileName }`;
};

const fetchIds = async (fileName: string): Promise<GattIds[]> => {
	const url = registryUrl(fileName);
	const text = await fetchAndCacheText(url);
	return text.split("\n")
		.map((line, index) => [ index + 1, line.trim() ] as [ number, string ])
		.filter(([ _lineNum, line ]) => !line.startsWith("#") && line !== "")
		.map(([ lineNum, line ]) => {
			const match = /^(\S+) ([-0-9a-fA-F]{36})$/.exec(line);
			if (match == null || match.length !== 3) {
				console.warn(`(${ fileName }:${ lineNum }) Unexpected line: ${ line }`);
				return undefined;
			}
			const [ _all, name, uuid ] = match as unknown as [ string, string, string ];
			const id = Number.parseInt(uuid.split("-")[ 0 ]!.replace(/^0+/, ""), 16);
			return { fileName, id, lineNum, name, uuid: uuid.toLocaleLowerCase() };
		})
		.filter((ids) => ids != null)
		.sort((a, b) => a.name.localeCompare(b.name));
};

interface GattIdGroups {
	characteristics: GattIds[];
	descriptors: GattIds[];
	services: GattIds[];
}

const fetchData = async (): Promise<GattIdGroups> => {
	const services = await fetchIds("gatt_assigned_services.txt");
	const descriptors = await fetchIds("gatt_assigned_descriptors.txt");
	const characteristics = await fetchIds("gatt_assigned_characteristics.txt");
	return { characteristics, descriptors, services };
};

const generateAssignedTS = (groups: GattIdGroups): string => {
	const asObject = (ids: GattIds[], valueFormatter: (id: GattIds) => string): string => {
		const lines: string[] = [ "{" ];
		for (const id of ids) {
			let key: string;
			if (/^\p{ID_Start}\p{ID_Continue}+$/u.test(id.name)) {
				key = id.name;
			} else {
				key = JSON.stringify(id.name);
			}
			const value = valueFormatter(id);
			lines.push(`\t${ key }: ${ value },`);
		}
		lines.push("}");
		return lines.join("\n");
	};
	return [
		"// This file is automatically generated.  Do not edit by hand.",
		"",
		"// noinspection SpellCheckingInspection",
		`export const GATT_SERVICE_UUID = Object.freeze(${ asObject(groups.services, (id) => JSON.stringify(id.uuid)) } as const);`,
		"",
		`export type GattServiceName = keyof typeof GATT_SERVICE_UUID;`,
		"",
		"// noinspection SpellCheckingInspection",
		`export const GATT_SERVICE_ID = Object.freeze(${ asObject(groups.services, (id) => "0x".concat(id.id.toString(16))) } as const);`,
		"",
		"// noinspection SpellCheckingInspection",
		`export const GATT_CHARACTERISTIC_UUID = Object.freeze(${ asObject(groups.characteristics, (id) => JSON.stringify(id.uuid)) } as const);`,
		"",
		`export type GattCharacteristicName = keyof typeof GATT_CHARACTERISTIC_UUID;`,
		"",
		"// noinspection SpellCheckingInspection",
		`export const GATT_CHARACTERISTIC_ID = Object.freeze(${ asObject(groups.characteristics, (id) => "0x".concat(id.id.toString(16))) } as const);`,
		"",
		"// noinspection SpellCheckingInspection",
		`export const GATT_DESCRIPTOR_UUID = Object.freeze(${ asObject(groups.descriptors, (id) => JSON.stringify(id.uuid)) } as const);`,
		"",
		`export type GattDescriptorName = keyof typeof GATT_DESCRIPTOR_UUID;`,
		"",
		"// noinspection SpellCheckingInspection",
		`export const GATT_DESCRIPTOR_ID = Object.freeze(${ asObject(groups.descriptors, (id) => "0x".concat(id.id.toString(16))) } as const);`,
		"",
	].join("\n");
};

const gattAssigned = async (): Promise<void> => {
	const outFile = pathResolve(__dirname, "..", "assigned.ts");
	const data = await fetchData();
	const ts = generateAssignedTS(data);
	await writeFile(outFile, ts, { encoding: "utf-8" });
};

gattAssigned().catch(catchAnd({ rethrow: true }));
